{
  "version": 3,
  "sources": ["../../src/array/sort-by-order.ts"],
  "sourcesContent": ["/**\n * Immutably sorts an array based on a given custom order, as specified by a separate list of identifiers.\n *\n * Note: Make sure that the identifier is unique for each item in the array.\n * If the identifier is not unique, only the last occurrence of the identifier will be sorted.\n * Any other elements will be overridden by the last occurrence of the identifier.\n *\n * This function efficiently arranges elements of an input array so that items whose IDs (obtained via the `getId` callback)\n * match the order array will appear first, strictly in the order specified. Items not found in the order array will be\n * appended after, maintaining their original order.\n *\n * This is a flexible utility: the identifier can be extracted from any data structure via the `getId` callback,\n * and any primitive (string, number, symbol, etc.) can serve as the identifier type.\n * Sorting is O(n) with respect to the array size, making it performant even for large arrays.\n *\n * @template T - The type of array elements.\n * @template N - The type of values in the order array and the identifier returned by the getId callback.\n * @param arr - The array to be sorted.\n * @param order - Array specifying the desired sequence (contains identifiers returned by getId).\n * @param getId - A callback to extract the unique identifier from each array element.\n * @returns A new array sorted according to the order provided, with unmatched elements following.\n *\n * @example\n * // Sorting an array of objects:\n * const items = [\n *   { id: 'a', name: 'Alpha' },\n *   { id: 'b', name: 'Bravo' },\n *   { id: 'c', name: 'Charlie' }\n * ];\n * const order = ['c', 'a'];\n * const sorted = sortByOrder(items, order, item => item.id);\n * // Result:\n * // [\n * //   { id: 'c', name: 'Charlie' },\n * //   { id: 'a', name: 'Alpha' },\n * //   { id: 'b', name: 'Bravo' }\n * // ]\n *\n * @example\n * // Sorting an array of primitive values:\n * const input = ['a', 'b', 'c', 'd'];\n * const order = ['c', 'a'];\n * sortByOrder(input, order, item => item);\n * // Result: ['c', 'a', 'b', 'd']\n */\nexport function sortByOrder<T, N>(arr: T[], order: N[], getId: (item: T) => N): T[] {\n  // Map the order to keep a single lookup table\n  const orderMap = new Map<N, number>()\n  order.forEach((e, idx) => orderMap.set(e, idx))\n\n  const sorted: T[] = []\n  const untagged: T[] = []\n\n  arr.forEach((e) => {\n    const sortedIdx = orderMap.get(getId(e))\n    if (sortedIdx === undefined) {\n      untagged.push(e)\n      return\n    }\n    sorted[sortedIdx] = e\n  })\n\n  return [...sorted.filter((it) => it !== undefined), ...untagged]\n}\n"],
  "mappings": "AA6CO,SAAS,YAAkB,KAAU,OAAY,OAA4B;AAElF,QAAM,WAAW,oBAAI,IAAe;AACpC,QAAM,QAAQ,CAAC,GAAG,QAAQ,SAAS,IAAI,GAAG,GAAG,CAAC;AAE9C,QAAM,SAAc,CAAC;AACrB,QAAM,WAAgB,CAAC;AAEvB,MAAI,QAAQ,CAAC,MAAM;AACjB,UAAM,YAAY,SAAS,IAAI,MAAM,CAAC,CAAC;AACvC,QAAI,cAAc,QAAW;AAC3B,eAAS,KAAK,CAAC;AACf;AAAA,IACF;AACA,WAAO,SAAS,IAAI;AAAA,EACtB,CAAC;AAED,SAAO,CAAC,GAAG,OAAO,OAAO,CAAC,OAAO,OAAO,MAAS,GAAG,GAAG,QAAQ;AACjE;",
  "names": []
}
